<!DOCTYPE html>
<html>
<head>
  <title>Price vs Expected Price</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

<h2>Data status</h2>
<p style="color:#888;font-size:14px;">Latest row in each table — quick check that pipelines are running.</p>
<table id="lastUpdatedTable" style="border-collapse:collapse;margin-bottom:24px;min-width:320px;">
  <thead>
    <tr style="border-bottom:1px solid #333;">
      <th style="text-align:left;padding:8px 12px;">Table</th>
      <th style="text-align:left;padding:8px 12px;">Last updated</th>
    </tr>
  </thead>
  <tbody>
    <tr><td colspan="2" style="padding:8px 12px;color:#888;">Loading…</td></tr>
  </tbody>
</table>

<h2>Seers ring: actual price vs expected (calculated) price</h2>
<p style="color:#888;font-size:14px;">Actual = mid price from <code>prices</code>. Expected = calculated from <code>price_models</code> (stored in <code>expected_prices</code>).</p>
<div style="max-width:1000px;height:420px;">
  <canvas id="chart"></canvas>
</div>

<h2>Seers ring: Bayesian expected price (updates with each observation)</h2>
<p style="color:#888;font-size:14px;">Same data; expected = Bayesian posterior mean (normal–normal update). No retrain — it updates as each new price arrives.</p>
<div style="max-width:1000px;height:420px;">
  <canvas id="chartBayesian"></canvas>
</div>

<h2>Log a trade</h2>
<p style="color:#888;font-size:14px;">Seers ring only. Stored in Supabase <code>trades</code> table.</p>

<div style="display:flex;flex-wrap:wrap;gap:32px;margin-bottom:24px;">
  <div style="border:1px solid #444;padding:16px;border-radius:8px;">
    <h3 style="margin-top:0;">Buy</h3>
    <p style="color:#888;font-size:13px;margin-bottom:12px;">Item = Seers ring</p>
    <form id="tradeFormBuy">
      <div style="margin-bottom:8px;">
        <label for="buyQty">Quantity</label>
        <input id="buyQty" type="number" min="1" value="1" style="margin-left:8px;padding:6px;width:80px;" />
      </div>
      <div style="margin-bottom:8px;">
        <label for="buyTotal">Total GP</label>
        <input id="buyTotal" type="number" min="0" step="1" required placeholder="e.g. 950000" style="margin-left:8px;padding:6px;width:140px;" />
      </div>
      <button type="submit" style="padding:8px 16px;">Save buy</button>
      <span id="tradeFormMessageBuy" style="margin-left:12px;color:#888;"></span>
    </form>
  </div>
  <div style="border:1px solid #444;padding:16px;border-radius:8px;">
    <h3 style="margin-top:0;">Sell</h3>
    <p style="color:#888;font-size:13px;margin-bottom:12px;">Item = Seers ring · total after GE tax</p>
    <form id="tradeFormSell">
      <div style="margin-bottom:8px;">
        <label for="sellQty">Quantity</label>
        <input id="sellQty" type="number" min="1" value="1" style="margin-left:8px;padding:6px;width:80px;" />
      </div>
      <div style="margin-bottom:8px;">
        <label for="sellTotal">Total GP after tax</label>
        <input id="sellTotal" type="number" min="0" step="1" required placeholder="e.g. 980000" style="margin-left:8px;padding:6px;width:140px;" />
      </div>
      <button type="submit" style="padding:8px 16px;">Save sell</button>
      <span id="tradeFormMessageSell" style="margin-left:12px;color:#888;"></span>
    </form>
  </div>
</div>

<h3>Recent trades</h3>
<table id="tradesTable" style="border-collapse:collapse;min-width:400px;">
  <thead>
    <tr style="border-bottom:1px solid #333;">
      <th style="text-align:left;padding:8px 12px;">Time</th>
      <th style="text-align:left;padding:8px 12px;">Item</th>
      <th style="text-align:left;padding:8px 12px;">Side</th>
      <th style="text-align:right;padding:8px 12px;">Total GP</th>
      <th style="text-align:right;padding:8px 12px;">Qty</th>
      <th style="text-align:right;padding:8px 12px;">Per unit</th>
    </tr>
  </thead>
  <tbody>
    <tr><td colspan="6" style="padding:8px 12px;color:#888;">Loading…</td></tr>
  </tbody>
</table>

<script>

const SUPABASE_URL = "https://goabrqjuguybmvjlqylq.supabase.co";
const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdvYWJycWp1Z3V5Ym12amxxeWxxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzEyNjMxOTgsImV4cCI6MjA4NjgzOTE5OH0.INEv8kOskPZO6fU6827a9XZkkl8Smzqht5_KVDzQ_Ro";

const FIVE_MIN = 300;
const FIFTEEN_MIN = 900;
const THIRTY_MIN = 1800;

const TWO_DAYS = 2 * 24 * 3600;

function formatFifteenMin(ts) {
  const rounded = Math.floor(ts / FIFTEEN_MIN) * FIFTEEN_MIN;
  const d = new Date(rounded * 1000);
  const h = d.getHours();
  const m = d.getMinutes();
  return String(h).padStart(2, "0") + ":" + String(m).padStart(2, "0");
}

function formatLabelWithDate(ts) {
  const d = new Date(ts * 1000);
  const day = d.getDate();
  const month = d.toLocaleString("en-GB", { month: "short" });
  const h = d.getHours();
  const m = d.getMinutes();
  return day + " " + month + " " + String(h).padStart(2, "0") + ":" + String(m).padStart(2, "0");
}

// Sequential Bayesian update: prior N(m, V), observe y ~ N(μ, σ²_obs) → posterior (m1, V1).
// Returns { means: number[], stds: number[] }.
function bayesianUpdateSequence(observations, obsVariance) {
  const n = observations.length;
  if (n === 0) return { means: [], stds: [] };
  const mean0 = observations[0];
  const V0 = 1e10; // weak prior
  let m = mean0;
  let V = V0;
  const means = [];
  const stds = [];
  for (let i = 0; i < n; i++) {
    const y = observations[i];
    const precPost = 1 / V + 1 / obsVariance;
    const Vnew = 1 / precPost;
    const mnew = Vnew * (m / V + y / obsVariance);
    means.push(Math.round(mnew));
    stds.push(Math.sqrt(Vnew));
    m = mnew;
    V = Vnew;
  }
  return { means, stds };
}

function showError(msg) {
  const p = document.createElement("p");
  p.style.color = "#f88";
  p.textContent = msg;
  document.body.appendChild(p);
}

async function loadData() {
  try {
    const priceRes = await fetch(
      `${SUPABASE_URL}/rest/v1/prices?item_id=eq.6731&order=timestamp.asc`,
      {
        headers: {
          apikey: SUPABASE_KEY,
          Authorization: `Bearer ${SUPABASE_KEY}`,
          Range: "0-99999"
        }
      }
    );
    if (!priceRes.ok) {
      showError("Prices: " + priceRes.status + " " + (await priceRes.text()).slice(0, 100));
      return;
    }
    let prices = await priceRes.json();
    if (!Array.isArray(prices) || prices.length === 0) {
      showError("No price data yet.");
      return;
    }
    const now = Math.floor(Date.now() / 1000);
    const cutoff = now - TWO_DAYS;
    prices = prices.filter(p => p.timestamp >= cutoff);

    let model = null;
    try {
      const modelRes = await fetch(
        `${SUPABASE_URL}/rest/v1/price_models?item_id=eq.6731&order=calculated_at.desc`,
        { headers: { apikey: SUPABASE_KEY, Authorization: `Bearer ${SUPABASE_KEY}`, Range: "0-0" } }
      );
      if (modelRes.ok) {
        const data = await modelRes.json();
        model = Array.isArray(data) && data.length ? data[0] : null;
      }
    } catch (_) {}

    const indices = [];
    let lastBucket = null;
    for (let i = 0; i < prices.length; i++) {
      const b = Math.floor(prices[i].timestamp / FIFTEEN_MIN) * FIFTEEN_MIN;
      if (lastBucket !== b) {
        lastBucket = b;
        indices.push(i);
      }
    }

    const realPrice = indices.map(i => prices[i].mid_price);
    const timestamps = indices.map(i => prices[i].timestamp);
    const labels = timestamps.map(ts => formatLabelWithDate(ts));

    let expectedPrice = indices.map(() => null);
    if (model && typeof model.intercept === "number") {
      expectedPrice = indices.map(i => {
        const p = prices[i];
        const spread = p.spread ?? 0;
        const vol = p.volume ?? 0;
        const coefSpread = model.coef_spread != null ? model.coef_spread : 0;
        const coefVol = model.coef_volume != null ? model.coef_volume : 0;
        return Math.round(model.intercept + coefSpread * spread + coefVol * vol);
      });
    } else {
      try {
        const epRes = await fetch(
          `${SUPABASE_URL}/rest/v1/expected_prices_data?item_id=eq.6731&order=last_updated.asc`,
          { headers: { apikey: SUPABASE_KEY, Authorization: `Bearer ${SUPABASE_KEY}`, Range: "0-99999" } }
        );
        if (epRes.ok) {
          const epRows = await epRes.json();
          if (Array.isArray(epRows) && epRows.length > 0) {
            const epByTs = {};
            epRows.forEach(r => {
              const ts = Math.floor(new Date(r.last_updated).getTime() / 1000);
              const bucket = Math.floor(ts / FIFTEEN_MIN) * FIFTEEN_MIN;
              epByTs[bucket] = r.expected_price;
            });
            expectedPrice = indices.map(i => {
              const bucket = Math.floor(prices[i].timestamp / FIFTEEN_MIN) * FIFTEEN_MIN;
              const v = epByTs[bucket];
              return v != null ? Number(v) : null;
            });
          }
        }
      } catch (_) {}
    }

    drawChart(labels, realPrice, expectedPrice);

    const avg = realPrice.reduce((a, b) => a + b, 0) / realPrice.length;
    const obsVariance = realPrice.length > 1
      ? Math.max(1e6, realPrice.reduce((s, p) => s + (p - avg) ** 2, 0) / realPrice.length)
      : 1e8;
    const { means: bayesianMeans, stds: bayesianStds } = bayesianUpdateSequence(realPrice, obsVariance);
    drawBayesianChart(labels, realPrice, bayesianMeans, bayesianStds);
  } catch (e) {
    showError("Error: " + e.message);
  }
}

let chartInstance = null;

function drawChart(labels, realPrice, expectedPrice) {
  if (chartInstance) {
    chartInstance.destroy();
    chartInstance = null;
  }
  chartInstance = new Chart(document.getElementById("chart"), {
    type: "line",
    data: {
      labels: labels,
      datasets: [
        { label: "Actual price", data: realPrice, borderColor: "rgb(0,200,255)", tension: 0.1 },
        { label: "Expected (calculated) price", data: expectedPrice, borderColor: "rgb(255,180,0)", borderDash: [6, 4], borderWidth: 2, tension: 0.1, spanGaps: true }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          ticks: {
            maxTicksLimit: 14,
            autoSkip: true,
            callback: function(_, i) { return this.chart.data.labels[i] || ""; }
          }
        }
      }
    }
  });
}

let chartBayesianInstance = null;

function drawBayesianChart(labels, realPrice, bayesianMeans, bayesianStds) {
  if (chartBayesianInstance) {
    chartBayesianInstance.destroy();
    chartBayesianInstance = null;
  }
  const upper = bayesianMeans.map((m, i) => m + 2 * bayesianStds[i]);
  const lower = bayesianMeans.map((m, i) => m - 2 * bayesianStds[i]);
  chartBayesianInstance = new Chart(document.getElementById("chartBayesian"), {
    type: "line",
    data: {
      labels: labels,
      datasets: [
        { label: "90% band", data: lower, borderColor: "rgba(180,100,255,0.25)", backgroundColor: "rgba(180,100,255,0.12)", fill: "+1", pointRadius: 0, tension: 0.1 },
        { label: "", data: upper, borderColor: "rgba(180,100,255,0.25)", fill: false, pointRadius: 0, tension: 0.1 },
        { label: "Actual price", data: realPrice, borderColor: "rgb(0,200,255)", tension: 0.1 },
        { label: "Bayesian expected", data: bayesianMeans, borderColor: "rgb(180,100,255)", borderDash: [6, 4], borderWidth: 2, tension: 0.1, spanGaps: true }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          ticks: {
            maxTicksLimit: 14,
            autoSkip: true,
            callback: function(_, i) { return this.chart.data.labels[i] || ""; }
          }
        }
      }
    }
  });
}

async function loadLastUpdated() {
  const headers = { apikey: SUPABASE_KEY, Authorization: `Bearer ${SUPABASE_KEY}` };
  const rows = [
    { table: "prices", label: "prices" },
    { table: "expected_prices", label: "expected_prices" },
    { table: "expected_prices_data", label: "expected_prices_data" },
    { table: "price_models", label: "price_models" }
  ];

  const out = [];
  for (const { table, label } of rows) {
    let dateStr = "—";
    try {
      let url = "";
      let dateKey = "";
      if (table === "prices") {
        url = `${SUPABASE_URL}/rest/v1/prices?order=timestamp.desc`;
        dateKey = "timestamp";
      } else if (table === "expected_prices") {
        url = `${SUPABASE_URL}/rest/v1/expected_prices?order=last_updated.desc`;
        dateKey = "last_updated";
      } else if (table === "expected_prices_data") {
        url = `${SUPABASE_URL}/rest/v1/expected_prices_data?order=last_updated.desc`;
        dateKey = "last_updated";
      } else if (table === "price_models") {
        url = `${SUPABASE_URL}/rest/v1/price_models?order=calculated_at.desc`;
        dateKey = "calculated_at";
      }
      const res = await fetch(url, { headers: { ...headers, Range: "0-0" } });
      if (res.ok) {
        const data = await res.json();
        const row = Array.isArray(data) ? data[0] : data;
        if (row) {
          const val = row[dateKey];
          if (val != null) {
            const d = typeof val === "number" ? new Date(val * 1000) : new Date(val);
            dateStr = d.toLocaleString();
          }
        }
      }
    } catch (_) {}
    out.push(`<tr style="border-bottom:1px solid #222;"><td style="padding:8px 12px;">${label}</td><td style="padding:8px 12px;">${dateStr}</td></tr>`);
  }

  const tbody = document.querySelector("#lastUpdatedTable tbody");
  if (tbody) tbody.innerHTML = out.join("");
}

async function loadTrades() {
  const tbody = document.querySelector("#tradesTable tbody");
  if (!tbody) return;
  try {
    const res = await fetch(
      `${SUPABASE_URL}/rest/v1/trades?order=traded_at.desc&limit=50`,
      { headers: { apikey: SUPABASE_KEY, Authorization: `Bearer ${SUPABASE_KEY}` } }
    );
    if (!res.ok) {
      tbody.innerHTML = `<tr><td colspan="6" style="padding:8px 12px;color:#f88;">Failed to load trades (${res.status})</td></tr>`;
      return;
    }
    const rows = await res.json();
    if (!Array.isArray(rows) || rows.length === 0) {
      tbody.innerHTML = "<tr><td colspan=\"6\" style=\"padding:8px 12px;color:#888;\">No trades yet.</td></tr>";
      return;
    }
    tbody.innerHTML = rows.map(r => {
      const at = r.traded_at ? new Date(r.traded_at).toLocaleString() : "—";
      const qty = Number(r.quantity) || 1;
      const total = Number(r.price);
      const perUnit = qty > 0 ? Math.round(total / qty) : "—";
      return `<tr style="border-bottom:1px solid #222;"><td style="padding:8px 12px;">${at}</td><td style="padding:8px 12px;">${escapeHtml(r.item_name)}</td><td style="padding:8px 12px;">${r.side}</td><td style="padding:8px 12px;text-align:right;">${total.toLocaleString()}</td><td style="padding:8px 12px;text-align:right;">${qty}</td><td style="padding:8px 12px;text-align:right;">${typeof perUnit === "number" ? perUnit.toLocaleString() : perUnit}</td></tr>`;
    }).join("");
  } catch (e) {
    tbody.innerHTML = `<tr><td colspan="6" style="padding:8px 12px;color:#f88;">Error: ${escapeHtml(e.message)}</td></tr>`;
  }
}

function escapeHtml(s) {
  const div = document.createElement("div");
  div.textContent = s;
  return div.innerHTML;
}

function saveTrade(side, quantity, totalGp, messageEl) {
  messageEl.textContent = "Saving…";
  messageEl.style.color = "#888";
  fetch(`${SUPABASE_URL}/rest/v1/trades`, {
    method: "POST",
    headers: {
      apikey: SUPABASE_KEY,
      Authorization: `Bearer ${SUPABASE_KEY}`,
      "Content-Type": "application/json",
      Prefer: "return=representation"
    },
    body: JSON.stringify({ item_name: "Seers ring", side, quantity, price: totalGp })
  }).then(res => {
    if (!res.ok) return res.text().then(t => { throw new Error(t || res.status); });
    messageEl.textContent = "Saved.";
    messageEl.style.color = "#6a6";
    if (side === "buy") {
      document.getElementById("buyQty").value = "1";
      document.getElementById("buyTotal").value = "";
    } else {
      document.getElementById("sellQty").value = "1";
      document.getElementById("sellTotal").value = "";
    }
    loadTrades();
  }).catch(err => {
    messageEl.textContent = "Error: " + err.message;
    messageEl.style.color = "#f88";
  });
}

document.getElementById("tradeFormBuy").addEventListener("submit", (e) => {
  e.preventDefault();
  const qty = Number(document.getElementById("buyQty").value) || 1;
  const total = Number(document.getElementById("buyTotal").value);
  if (total < 0) {
    document.getElementById("tradeFormMessageBuy").textContent = "Enter total GP.";
    document.getElementById("tradeFormMessageBuy").style.color = "#f88";
    return;
  }
  saveTrade("buy", qty, total, document.getElementById("tradeFormMessageBuy"));
});

document.getElementById("tradeFormSell").addEventListener("submit", (e) => {
  e.preventDefault();
  const qty = Number(document.getElementById("sellQty").value) || 1;
  const total = Number(document.getElementById("sellTotal").value);
  if (total < 0) {
    document.getElementById("tradeFormMessageSell").textContent = "Enter total GP after tax.";
    document.getElementById("tradeFormMessageSell").style.color = "#f88";
    return;
  }
  saveTrade("sell", qty, total, document.getElementById("tradeFormMessageSell"));
});

loadLastUpdated();
loadData();
loadTrades();
setInterval(loadLastUpdated, 60000);

</script>

</body>
</html>
