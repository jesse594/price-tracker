<!DOCTYPE html>
<html>
<head>
  <title>Price vs Expected Price</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

<h2>Data status</h2>
<p style="color:#888;font-size:14px;">Latest row in each table — quick check that pipelines are running.</p>
<table id="lastUpdatedTable" style="border-collapse:collapse;margin-bottom:24px;min-width:320px;">
  <thead>
    <tr style="border-bottom:1px solid #333;">
      <th style="text-align:left;padding:8px 12px;">Table</th>
      <th style="text-align:left;padding:8px 12px;">Last updated</th>
    </tr>
  </thead>
  <tbody>
    <tr><td colspan="2" style="padding:8px 12px;color:#888;">Loading…</td></tr>
  </tbody>
</table>

<h2>Seers ring: actual price vs expected (calculated) price</h2>
<p style="color:#888;font-size:14px;">Actual = mid price from <code>prices</code>. Expected = calculated from <code>price_models</code> (stored in <code>expected_prices</code>).</p>
<div style="max-width:1000px;height:420px;">
  <canvas id="chart"></canvas>
</div>

<script>

const SUPABASE_URL = "https://goabrqjuguybmvjlqylq.supabase.co";
const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdvYWJycWp1Z3V5Ym12amxxeWxxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzEyNjMxOTgsImV4cCI6MjA4NjgzOTE5OH0.INEv8kOskPZO6fU6827a9XZkkl8Smzqht5_KVDzQ_Ro";

const FIVE_MIN = 300;
const FIFTEEN_MIN = 900;
const THIRTY_MIN = 1800;

const TWO_DAYS = 2 * 24 * 3600;

function formatFifteenMin(ts) {
  const rounded = Math.floor(ts / FIFTEEN_MIN) * FIFTEEN_MIN;
  const d = new Date(rounded * 1000);
  const h = d.getHours();
  const m = d.getMinutes();
  return String(h).padStart(2, "0") + ":" + String(m).padStart(2, "0");
}

function formatLabelWithDate(ts) {
  const d = new Date(ts * 1000);
  const day = d.getDate();
  const month = d.toLocaleString("en-GB", { month: "short" });
  const h = d.getHours();
  const m = d.getMinutes();
  return day + " " + month + " " + String(h).padStart(2, "0") + ":" + String(m).padStart(2, "0");
}

function showError(msg) {
  const p = document.createElement("p");
  p.style.color = "#f88";
  p.textContent = msg;
  document.body.appendChild(p);
}

async function loadData() {
  try {
    const priceRes = await fetch(
      `${SUPABASE_URL}/rest/v1/prices?item_id=eq.6731&order=timestamp.asc`,
      {
        headers: {
          apikey: SUPABASE_KEY,
          Authorization: `Bearer ${SUPABASE_KEY}`,
          Range: "0-99999"
        }
      }
    );
    if (!priceRes.ok) {
      showError("Prices: " + priceRes.status + " " + (await priceRes.text()).slice(0, 100));
      return;
    }
    let prices = await priceRes.json();
    if (!Array.isArray(prices) || prices.length === 0) {
      showError("No price data yet.");
      return;
    }
    const now = Math.floor(Date.now() / 1000);
    const cutoff = now - TWO_DAYS;
    prices = prices.filter(p => p.timestamp >= cutoff);

    let model = null;
    try {
      const modelRes = await fetch(
        `${SUPABASE_URL}/rest/v1/price_models?item_id=eq.6731&order=calculated_at.desc`,
        { headers: { apikey: SUPABASE_KEY, Authorization: `Bearer ${SUPABASE_KEY}`, Range: "0-0" } }
      );
      if (modelRes.ok) {
        const data = await modelRes.json();
        model = Array.isArray(data) && data.length ? data[0] : null;
      }
    } catch (_) {}

    const indices = [];
    let lastBucket = null;
    for (let i = 0; i < prices.length; i++) {
      const b = Math.floor(prices[i].timestamp / FIFTEEN_MIN) * FIFTEEN_MIN;
      if (lastBucket !== b) {
        lastBucket = b;
        indices.push(i);
      }
    }

    const realPrice = indices.map(i => prices[i].mid_price);
    const timestamps = indices.map(i => prices[i].timestamp);
    const labels = timestamps.map(ts => formatLabelWithDate(ts));

    let expectedPrice = indices.map(() => null);
    if (model && typeof model.intercept === "number") {
      expectedPrice = indices.map(i => {
        const p = prices[i];
        const spread = p.spread ?? 0;
        const vol = p.volume ?? 0;
        const coefSpread = model.coef_spread != null ? model.coef_spread : 0;
        const coefVol = model.coef_volume != null ? model.coef_volume : 0;
        return Math.round(model.intercept + coefSpread * spread + coefVol * vol);
      });
    } else {
      try {
        const epRes = await fetch(
          `${SUPABASE_URL}/rest/v1/expected_prices_data?item_id=eq.6731&order=last_updated.asc`,
          { headers: { apikey: SUPABASE_KEY, Authorization: `Bearer ${SUPABASE_KEY}`, Range: "0-99999" } }
        );
        if (epRes.ok) {
          const epRows = await epRes.json();
          if (Array.isArray(epRows) && epRows.length > 0) {
            const epByTs = {};
            epRows.forEach(r => {
              const ts = Math.floor(new Date(r.last_updated).getTime() / 1000);
              const bucket = Math.floor(ts / FIFTEEN_MIN) * FIFTEEN_MIN;
              epByTs[bucket] = r.expected_price;
            });
            expectedPrice = indices.map(i => {
              const bucket = Math.floor(prices[i].timestamp / FIFTEEN_MIN) * FIFTEEN_MIN;
              const v = epByTs[bucket];
              return v != null ? Number(v) : null;
            });
          }
        }
      } catch (_) {}
    }

    drawChart(labels, realPrice, expectedPrice);
  } catch (e) {
    showError("Error: " + e.message);
  }
}

let chartInstance = null;

function drawChart(labels, realPrice, expectedPrice) {
  if (chartInstance) {
    chartInstance.destroy();
    chartInstance = null;
  }
  chartInstance = new Chart(document.getElementById("chart"), {
    type: "line",
    data: {
      labels: labels,
      datasets: [
        { label: "Actual price", data: realPrice, borderColor: "rgb(0,200,255)", tension: 0.1 },
        { label: "Expected (calculated) price", data: expectedPrice, borderColor: "rgb(255,180,0)", borderDash: [6, 4], borderWidth: 2, tension: 0.1, spanGaps: true }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          ticks: {
            maxTicksLimit: 14,
            autoSkip: true,
            callback: function(_, i) { return this.chart.data.labels[i] || ""; }
          }
        }
      }
    }
  });
}

async function loadLastUpdated() {
  const headers = { apikey: SUPABASE_KEY, Authorization: `Bearer ${SUPABASE_KEY}` };
  const rows = [
    { table: "prices", label: "prices" },
    { table: "expected_prices", label: "expected_prices" },
    { table: "expected_prices_data", label: "expected_prices_data" },
    { table: "price_models", label: "price_models" }
  ];

  const out = [];
  for (const { table, label } of rows) {
    let dateStr = "—";
    try {
      let url = "";
      let dateKey = "";
      if (table === "prices") {
        url = `${SUPABASE_URL}/rest/v1/prices?order=timestamp.desc`;
        dateKey = "timestamp";
      } else if (table === "expected_prices") {
        url = `${SUPABASE_URL}/rest/v1/expected_prices?order=last_updated.desc`;
        dateKey = "last_updated";
      } else if (table === "expected_prices_data") {
        url = `${SUPABASE_URL}/rest/v1/expected_prices_data?order=last_updated.desc`;
        dateKey = "last_updated";
      } else if (table === "price_models") {
        url = `${SUPABASE_URL}/rest/v1/price_models?order=calculated_at.desc`;
        dateKey = "calculated_at";
      }
      const res = await fetch(url, { headers: { ...headers, Range: "0-0" } });
      if (res.ok) {
        const data = await res.json();
        const row = Array.isArray(data) ? data[0] : data;
        if (row) {
          const val = row[dateKey];
          if (val != null) {
            const d = typeof val === "number" ? new Date(val * 1000) : new Date(val);
            dateStr = d.toLocaleString();
          }
        }
      }
    } catch (_) {}
    out.push(`<tr style="border-bottom:1px solid #222;"><td style="padding:8px 12px;">${label}</td><td style="padding:8px 12px;">${dateStr}</td></tr>`);
  }

  const tbody = document.querySelector("#lastUpdatedTable tbody");
  if (tbody) tbody.innerHTML = out.join("");
}

loadLastUpdated();
loadData();
setInterval(loadLastUpdated, 60000);

</script>

</body>
</html>
